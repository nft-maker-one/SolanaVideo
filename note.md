# Solana Â≠¶‰π†Á¨îËÆ∞
## Web3 ÂºÄÂèëËÄÖ‰∫§ÊµÅÁ§æÁæ§‰ªãÁªç‚Äã
üì¢ Â¶ÇÊûú‰Ω†‰πüÂú®Á†îÁ©∂Âå∫ÂùóÈìæÊäÄÊúØÔºåÁâπÂà´ÊòØÂØπ Solana Êô∫ËÉΩÂêàÁ∫¶ÂºÄÂèë„ÄÅÂå∫ÂùóÈìæÂéüÁêÜÊÑüÂÖ¥Ë∂£ÔºåÊ¨¢ËøéÂä†ÂÖ•Ëøô‰∏™‰∫§ÊµÅÁ§æÁæ§ÔºÅÊàëÁõÆÂâçÂú®Âà∂‰ΩúÁõ∏ÂÖ≥ÁöÑÊäÄÊúØÂàÜ‰∫´ËßÜÈ¢ëÔºåÂú®ËøôÈáåÔºåÊàë‰ª¨ÂèØ‰ª•‰∏ÄËµ∑ËÆ®ËÆ∫ËßÜÈ¢ëÂÜÖÂÆπÔºåÂàÜ‰∫´Â≠¶‰π†ÂøÉÂæó„ÄÇ‚Äã
‰∏çÁÆ°‰Ω†ÊòØÂàöÂÖ•Èó®ÁöÑÂ∞èÁôΩÔºåËøòÊòØÂ∑≤ÁªèÊúâ‰∏ÄÂÆöÁªèÈ™åÁöÑÂºÄÂèëËÄÖÔºåÈÉΩËÉΩÂú®ËøôÈáåÁïÖÊâÄÊ¨≤Ë®Ä„ÄÇÈÅáÂà∞ÊäÄÊúØÈöæÈ¢òÔºåÁæ§Âèã‰ª¨ÂèØ‰ª•‰∫íÁõ∏Â∏ÆÂøôÂá∫Ë∞ãÂàíÁ≠ñÔºõÊúâÊñ∞ÁöÑËßÅËß£ÂíåÂèëÁé∞Ôºå‰πüËÉΩÈöèÊó∂ÂíåÂ§ßÂÆ∂‰∫§ÊµÅ„ÄÇÊ≤°ÊúâÂçé‰∏ΩÁöÑÊ¥ªÂä®ÂåÖË£ÖÔºåÂ∞±ÊòØ‰∏ÄÁæ§ÁÉ≠Áà±Âå∫ÂùóÈìæÊäÄÊúØÁöÑ‰ºô‰º¥ÔºåË∏èË∏èÂÆûÂÆûÂ≠¶‰π†„ÄÅ‰∫§ÊµÅ„ÄÇ‚Äã

üì± Êâ´Êèè‰∏ãÊñπÁ§æÁæ§‰∫åÁª¥Á†ÅÔºåÂ∞±ËÉΩÁõ¥Êé•ÂÖ•Áæ§„ÄÇË¶ÅÊòØ‰∫åÁª¥Á†ÅÂ§±Êïà‰∫ÜÔºåÊ∑ªÂä†ÊàëÁöÑÂæÆ‰ø°ÔºàËßÅ‰∏ãÊñπÂæÆ‰ø°‰∫åÁª¥Á†ÅÂõæÁâáÔºâÔºåÂ§áÊ≥®„ÄêÂå∫ÂùóÈìæÂ≠¶‰π†„ÄëÔºåÊàëÊãâ‰Ω†ËøõÁæ§ÔºåÂí±‰ª¨‰∏ÄËµ∑Âú® Web3 ÁöÑ‰∏ñÁïåÈáåÊé¢Á¥¢ËøõÊ≠•ÔºÅ
![alt text](909f703f3c2c6b26afe407d0a078c776.jpg)
![alt text](a207c5d477752feca85e5b7307bdb1e2.jpg)

## Solana ÂÆûÁé∞ Hello world
Solana Êú¨Âú∞ÂºÄÂèëÁéØÂ¢ÉÁöÑÊê≠Âª∫ËæÉ‰∏∫Â§çÊùÇÔºåÂú®ÂàùÂ≠¶Èò∂ÊÆµÔºåÊé®ËçêÂ§ßÂÆ∂‰ΩøÁî® [Solana Playgroud](https://beta.solpg.io/) ËøõË°åÂºÄÂèë„ÄÇ‰∏äÈù¢ÊúâÊê≠Âª∫Â•ΩÁöÑ Solana ÂºÄÂèëÁéØÂ¢ÉÔºåÂπ∂‰∏îÊèê‰æõ‰∫Ü Solana Â∑•Á®ãÁöÑÂºÄÂèëÊ®°ÊùøÔºåÊòì‰∫éÂàùÂ≠¶ËÄÖ‰∏äÊâã.  
![alt text](image.png)  

ÊâìÂºÄÁïåÈù¢ÂêéÁÇπÂáªÂè≥‰∏äËßíÁöÑÂä†Âè∑ÂàõÂª∫Â∑•Á®ãÔºåÂπ∂‰∏îÂú®Â∑•Á®ãÈÄâÈ°π‰∏≠ÈÄâÊã© Native(Rust)ÔºåÊé•‰∏ãÊù•‰æøÂèØ‰ª•ËøõÂÖ•Â∑•Á®ãÁöÑÂºÄÂèë„ÄÇ  
### Êñá‰ª∂ÁõÆÂΩï‰ªãÁªç
Êñá‰ª∂ÂàõÂª∫ÂêéÔºåÊàë‰ª¨ÂèØ‰ª•ÁúãÂà∞ÁõÆÂΩï‰∏≠Êúâ‰∏â‰∏™Êñá‰ª∂Â§πÔºåÂàÜÂà´ÊòØ src,client,tests. ÂÖ∂‰∏≠ src Êñá‰ª∂Â§π‰∏ãÂ≠òÂÇ®‰∫ÜÂêàÁ∫¶Â∑•Á®ãÊñá‰ª∂ lib.rs,Áî®Êù•ÁºñÂÜôÊàë‰ª¨ÁöÑ Solana Êô∫ËÉΩÂêàÁ∫¶ÈÄªËæë„ÄÇ client Êñá‰ª∂Â§π‰∏ãÈù¢Â≠òÂÇ®‰∫Ü client.ts Êñá‰ª∂Ôºå‰∏∫Êàë‰ª¨Êèê‰æõ‰∫Ü‰∏Ä‰∏™‰∏é Solana ÁΩëÁªú‰∫§Êç¢ÁöÑÂâçÁ´ØÊ®°ÊùøÁ®ãÂ∫è„ÄÇÊúÄÂêéÁöÑ test Êñá‰ª∂Â§π‰∏ãÈù¢Â≠òÂÇ®‰∫Ü‰∏Ä‰∏™ÂØπ @solana/web3.js ‰∏≠ API ÂäüËÉΩÁöÑÊµãËØïÊñá‰ª∂„ÄÇ

![alt text](image-1.png)


### ÂêàÁ∫¶ÈÄªËæëÁºñËæë
ÊâìÂºÄ src Êñá‰ª∂Â§π‰∏ãÁöÑ lib.rs Êñá‰ª∂ÔºåÊàë‰ª¨Ê∏ÖÈô§Êéâ Solana Playground ÁªôÊàë‰ª¨Êèê‰æõÁöÑÂàùÂßãÊ®°ÊùøÔºåÂπ∂Ë¥¥ÂÖ•Êàë‰ª¨‰∏ãÈù¢ÁöÑ hello world Á®ãÂ∫è‰ª£Á†Å„ÄÇ  
 
```rust
use solana_program::{
    account_info::AccountInfo,
    entrypoint,
    entrypoint::ProgramResult,
    pubkey::Pubkey,
    msg,
};

entrypoint!(process_instruction);

pub fn process_instruction(
    _program_id: &Pubkey,
    _accounts:&[AccountInfo],
    _instruction_data:&[u8],
) -> ProgramResult {
    msg!("Hello world!!");
    Ok(())
}

```

ÂÆåÊàê‰ª£Á†ÅÂêéÔºåÊàë‰ª¨ÁÇπÂáªÁïåÈù¢Â∑¶‰æßÁöÑ build & deploy ÂõæÊ†áÔºå‰πãÂêéÂØπÊàë‰ª¨ÁöÑÂ∑•Á®ãËøõË°å buildÔºåbuild Âú®ÊéßÂà∂Âè∞ÊòæÁ§∫ÊàêÂäüÂêéÔºåÁÇπÂáª‰∏ãÊñπÁöÑ deploy ËøõË°åÂêàÁ∫¶ÈÉ®ÁΩ≤ÔºåËøôÊ†∑Êàë‰ª¨Â∞±ÂÆåÊàê‰∫Ü‰∏Ä‰∏™Solana Êô∫ËÉΩÂêàÁ∫¶Âú® devnet ÁΩëÁªú‰∏äÁöÑÈÉ®ÁΩ≤

![alt text](image-2.png)

ÈúÄË¶ÅÊ≥®ÊÑèÁöÑÊòØÔºåÈÉ®ÁΩ≤ÂêàÁ∫¶ÈúÄË¶Å Solana ‰Ωú‰∏∫ gas ÔºåÂ¶ÇÊûúË¥¶Êà∑ÂÜÖ Solana ‰∏çË∂≥ÁöÑËØùÔºåÂèØ‰ª•Âú®ÂëΩ‰ª§Ë°åÊâßË°å‰∏ãÈù¢ËØ≠Âè•Áî≥ËØ∑ Solana Á©∫Êäï

```shell
solana airdrop 2
```


### ÂâçÁ´ØÊñá‰ª∂ÊîπÂÜô
ËøõÂÖ• client ‰∏ãÁöÑ client.ts Êñá‰ª∂Â§π„ÄÇÂ§çÂà∂‰∏ãÈù¢ÂÜÖÂÆπ

```typescript
transaction.add({
  keys:[],
  programId:new web3.PublicKey(pg.PROGRAM_ID),
})
const txHash = await web3.sendAndConfirmTransaction(
  pg.connection,
  transaction,
  [pg.wallet.keypair],
)

console.log(txHash);
```


## Solana ÂÆûÁé∞ËÆøÈóÆËÆ°Êï∞Âô®

### ÂêàÁ∫¶ÈÄªËæë
```rust
use borsh::{BorshSerialize,BorshDeserialize};
use solana_program::{
    account_info::{AccountInfo,next_account_info},
    pubkey::Pubkey,
    entrypoint::ProgramResult,
    entrypoint,
    msg,
    program_error::ProgramError
};

#[derive(BorshSerialize,BorshDeserialize)]
pub struct Counter {
    num:i32
}

entrypoint!(process_instruction);

pub fn process_instruction(
    program_id:&Pubkey,
    accounts:&[AccountInfo],
    _instruction_data:&[u8]
) -> ProgramResult {
    let account_iter = &mut accounts.iter();
    let account = next_account_info(account_iter)?;
    if account.owner != program_id {
        return Err(ProgramError::IncorrectProgramId)
    }
    let mut counter = Counter::try_from_slice(&account.data.borrow())?;
    counter.num += 1;
    counter.serialize(&mut *account.data.borrow_mut())?;
    msg!("{} access for {} times",account.key.to_string(),counter.num);
    Ok(())
    
}


```




### ÂâçÁ´Ø‰∫§‰∫íÂíåSolanaÁöÑ‰∫§ÊòìÊ®°Âûã
#### Â∫èÂàóÂåñËßÑÂàôËÆæÁΩÆ
```typescript

class Counter {
  num:number
  constructor(fields:{num:number}|undefined=undefined) {
    if (fields) {
      this.num = fields.num;
    } 
  }
}

const Schema = new Map([
  [Counter,{kind:"struct",fields:[["num","u32"]]}]
])

const space = borsh.serialize(Schema,new Counter()).length
const lamports = await pg.connection.getMinimumBalanceForRentExemption(space);
const keypair = new web3.Keypair();


console.log("space = ",space)
console.log("lamports = ",lamports)

```


#### ‰∏ÄÊ¨°ËÆ°Êï∞ÁöÑÂÆåÊàê
```typescript

const createAccountTxIs = web3.SystemProgram.createAccount({
  fromPubkey:pg.wallet.publicKey,
  newAccountPubkey:keypair.publicKey,
  lamports,
  space:dataSize,
  programId:pg.PROGRAM_ID
});

const addTxIs = new web3.TransactionInstruction({
  keys:[
    {
      pubkey:keypair.publicKey,
      isSigner:false,
      isWritable:true
    }
  ],
  programId:pg.PROGRAM_ID
})

const tx = new web3.Transaction()
tx.add(createAccountTxIs,addTxIs);
const hash = await web3.sendAndConfirmTransaction(
  pg.connection,
  tx,
  [pg.wallet.keypair,keypair]
)


const tx1 = new web3.Transaction()
tx1.add({
  keys:[{
    pubkey:keypair.publicKey,
    isSigner:true,
    isWritable:true
  }],
  programId:pg.PROGRAM_ID
})
const hash1 = await web3.sendAndConfirmTransaction(pg.connection,tx1,[pg.wallet.keypair,keypair])

const rawCount = await pg.connection.getAccountInfo(keypair.publicKey)
const count = borsh.deserialize(
  Schema,
  Counter,
  rawCount.data
)



console.log("hash = ",hash1)
console.log(count)
console.log("counter.num = ",count.num)

```


![alt text](image-4.png)

AccountMeta Ê®°Âûã(Êù•Ê∫ê: solana.com/docs)


#### ‰∏ÄÁ¨î‰∫§Êòì‰∏ãÁöÑÂ§öÊ¨°ËÆ°Êï∞
```typescript
class Counter {
  num:number
  constructor(fields:{num:number}|undefined=undefined) {
    if (fields) {
      this.num = fields.num;
    } 
  }
}

const Schema = new Map([
  [Counter,{kind:"struct",fields:[["num","u32"]]}]
])

const space = borsh.serialize(Schema,new Counter()).length
const lamports = await pg.connection.getMinimumBalanceForRentExemption(space)
const keypair = new web3.Keypair()

const tx = new web3.Transaction()

const createAccountTxIs = web3.SystemProgram.createAccount({
  fromPubkey:pg.wallet.publicKey,
  newAccountPubkey:keypair.publicKey,
  space,
  lamports,
  programId:pg.PROGRAM_ID
})

const txIs = new web3.TransactionInstruction({
  keys:[
    {pubkey:keypair.publicKey,isSigner:false,isWritable:false}
  ],
  programId:pg.PROGRAM_ID
})

tx.add(createAccountTxIs,txIs,txIs,txIs)

const txHash = await web3.sendAndConfirmTransaction(pg.connection,tx,[pg.wallet.keypair,keypair])
console.log("txHash = ",txHash)


let account = await pg.connection.getAccountInfo(keypair.publicKey)
const counter = borsh.deserialize(Schema,Counter,account.data);
console.log("counter.num = ",counter.num);

```


#### solana Transaction

![alt text](image-5.png)


transaction ÁªìÊûÑ(Êù•Ê∫ê: solana.com/docs)



![solana Instruction(Êù•Ê∫ê: solana.com/docs)](image-3.png)

solana Instruction(Êù•Ê∫ê: solana.com/docs)

```javascript
// web3.sendAndCofrimTransaction
async function sendAndConfirmTransaction(connection, transaction, signers, options) {
  const sendOptions = options && {
    skipPreflight: options.skipPreflight,
    preflightCommitment: options.preflightCommitment || options.commitment,
    maxRetries: options.maxRetries,
    minContextSlot: options.minContextSlot
  };
  const signature = await connection.sendTransaction(transaction, signers, sendOptions);
  let status;
  if (transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null) {
    status = (await connection.confirmTransaction({
      abortSignal: options?.abortSignal,
      signature: signature,
      blockhash: transaction.recentBlockhash,
      lastValidBlockHeight: transaction.lastValidBlockHeight
    }, options && options.commitment)).value;
  } else if (transaction.minNonceContextSlot != null && transaction.nonceInfo != null) {
    const {
      nonceInstruction
    } = transaction.nonceInfo;
    const nonceAccountPubkey = nonceInstruction.keys[0].pubkey;
    status = (await connection.confirmTransaction({
      abortSignal: options?.abortSignal,
      minContextSlot: transaction.minNonceContextSlot,
      nonceAccountPubkey,
      nonceValue: transaction.nonceInfo.nonce,
      signature
    }, options && options.commitment)).value;
  } else {
    if (options?.abortSignal != null) {
      console.warn('sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was ' + 'supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` ' + 'or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.');
    }
    status = (await connection.confirmTransaction(signature, options && options.commitment)).value;
  }
  if (status.err) {
    if (signature != null) {
      throw new SendTransactionError({
        action: 'send',
        signature: signature,
        transactionMessage: `Status: (${JSON.stringify(status)})`
      });
    }
    throw new Error(`Transaction ${signature} failed (${JSON.stringify(status)})`);
  }
  return signature;
}
```


```javascript
// Á≠æÂêçÁÆóÊ≥ï
sign(...signers) {
    if (signers.length === 0) {
      throw new Error('No signers');
    }

    // Dedupe signers
    const seen = new Set();
    const uniqueSigners = [];
    for (const signer of signers) {
      const key = signer.publicKey.toString();
      if (seen.has(key)) {
        continue;
      } else {
        seen.add(key);
        uniqueSigners.push(signer);
      }
    }
    this.signatures = uniqueSigners.map(signer => ({
      signature: null,
      publicKey: signer.publicKey
    }));
    const message = this._compile();
    this._partialSign(message, ...uniqueSigners);
  }
```

#### Â§öÁ¨î‰∫§Êòì‰∏ãÁöÑÂ§öÊ¨°ËÆ°Êï∞
```typescript
class Counter {
  num:number
  constructor(fields:{num:number}|undefined=undefined) {
    if (fields) {
      this.num = fields.num;
    } 
  }
}

const Schema = new Map([
  [Counter,{kind:"struct",fields:[["num","u32"]]}]
])

const space = borsh.serialize(Schema,new Counter()).length
const lamports = await pg.connection.getMinimumBalanceForRentExemption(space);
const keypair = pg.wallet.keypair;


console.log("space = ",space)
console.log("lamports = ",lamports)

const tx = new web3.Transaction()


const createAccountTxIs = web3.SystemProgram.createAccount({
  fromPubkey:pg.wallet.publicKey,
  newAccountPubkey:keypair.publicKey,
  space,
  lamports,
  programId:pg.PROGRAM_ID
})

const txIs = new web3.TransactionInstruction({
  keys:[
    {pubkey:keypair.publicKey,isSigner:false,isWritable:true}
  ],
  programId:pg.PROGRAM_ID
})

tx.add(createAccountTxIs,txIs,txIs,txIs)

const txHash = await web3.sendAndConfirmTransaction(pg.connection,tx,[pg.wallet.keypair,keypair])
console.log("txHash = ",txHash)

const tx1 = new web3.Transaction()
const txIs1 = new web3.TransactionInstruction({
  keys:[
    {pubkey:keypair.publicKey,isSigner:true,isWritable:true}
  ],
  programId:pg.PROGRAM_ID
})
const transferIs = web3.SystemProgram.transfer({
  fromPubkey:pg.wallet.keypair.publicKey,
  toPubkey:keypair.publicKey,
  lamports:web3.LAMPORTS_PER_SOL/2
})

tx1.add(txIs1,transferIs)

const txHash1 = await web3.sendAndConfirmTransaction(pg.connection,tx1,[pg.wallet.keypair,keypair])

console.log("pubkey = ",keypair.publicKey.toString());
console.log("txHash1 = ",txHash1)

const tx2 = new web3.Transaction()
tx2.add(txIs1)
const txHash2 = await web3.sendAndConfirmTransaction(pg.connection,tx2,[keypair])

let account = await pg.connection.getAccountInfo(keypair.publicKey)
const counter = borsh.deserialize(Schema,Counter,account.data);
console.log("counter.num = ",counter.num);



```

#### solana Ë¥¶Êà∑ÊâÄÊúâÊùÉÊ®°Âûã
solana ‰∏≠‰ªª‰ΩïË¥¶Êà∑ÈÉΩÂΩíÊüê‰∏™ÂêàÁ∫¶ÊâÄÊúâÔºåËÄå‰∏çËÉΩÁã¨Á´ãÂ≠òÂú®„ÄÇÊàë‰ª¨Â∏∏Áî®Êù•‰∫§ÊòìÁöÑË¥¶Êà∑ÂΩí SystemProgram ÊâÄÊúâÔºåÂè™ÊúâÂÆÉÊâçÊîØÊåÅ Solana ÁöÑËΩ¨Ë¥¶‰∫§Êòì„ÄÇÂΩìÊàë‰ª¨ÂíåÊüê‰∏™ÂêàÁ∫¶(program)‰∫§‰∫í‰πãÂâç
ÂøÖÈ°ªÂÖàÂª∫Á´ã‰∏Ä‰∏™ËØ•ÂêàÁ∫¶ÊâÄÊúâÁöÑÂßîÊâòË¥¶Êà∑ÔºåÈÄöËøáÂßîÊâòË¥¶Êà∑ÊâçÂèØ‰ª•‰∏éËØ•ÂêàÁ∫¶‰∫§‰∫í„ÄÇ

![alt text](image-6.png)  
Âå∫ÂùóÊµèËßàÂô®‰∏≠Ë¥¶Êà∑ÊâÄÊúâÊùÉÁöÑÂ±ïÁ§∫



## rust Âü∫Êú¨ËØ≠Ê≥ï
[vs build](https://visualstudio.microsoft.com/zh-hans/downloads/?mode=dark)

[rustup download](https://www.rust-lang.org/zh-CN/tools/install)

### Á±ªÂûãÊé®Êñ≠
```rust
let a = 34;
let b:u8 = 12;
let c = "xxxx";
let d = String::from("xxxx");

```

### ÂèØÂèò‰øÆÈ•∞Á¨¶
```rust
let age = 32;
// age = 23;  Êä•Èîô
let mut money = 100
let money = 220

```


### ÂºïÁî®
```rust
pub fn main() {
    let mut hobby1 = String::from("football");
    let hobby2 = &mut hobby1;
    // let hobby3 = &hobby1
    println!("hobby1 =  hobby2 = {} hobby3 = ",hobby2);
}
```

### ‰ΩúÁî®Âüü
```rust
let animal1 = String::from("car");
{
    let animal2 = &animal1;
}
println!("animal2 = {}",animal);
```

### mod
### ÂêåÊñá‰ª∂‰∏ãÁöÑmodË∞ÉÁî®
```rust
mod sports {
    pub fn do_sports(s:String) {
        println!("I lke {}",s)
    }
}

sports::do_sports(String::from("ping-pong"));
```
### ‰∏çÂêåÊñá‰ª∂‰∏ãÁöÑmodË∞ÉÁî®
Êñá‰ª∂ÁõÆÂΩï
- src
  - main.rs
  - college
    - mod.rs
    - student.rs


```rust
// mod.rs
pub mod student;
```
```rust
// student.rs
pub struct Student {
    pub name:String,
    pub age:u32
}

impl Student {
    pub fn new(name:String,age:u32) -> Student {
        Student {name:name,age:age}
    }

    pub fn show_msg(&self){
        println!("name {} age {}",self.name,self.age);
    }
}
```
```rust
// main.rs
pub fn main() {
  let s = college::student::Student::new(String::from("Âº†‰∏â"),17);
  s.show_msg();
}
```

## ËÆ°Êï∞Âô®ÂêàÁ∫¶‰∏≠ÁöÑ rust ËØ≠Ê≥ï
### ÁªìÊûÑ‰Ωì
rust ÂèØ‰ª•ÂÆö‰πâÂ≠óÊÆµÂíåÁªìÊûÑ‰ΩìÊñπÊ≥ïÔºåÂÖ∂ÊòØ rust ‰∏≠Èù¢ÂêëÂØπË±°ÁºñÁ®ãÁöÑÂÆûÁé∞„ÄÇ
```rust
pub struct Student {
    name:String,
    age:u8,
    score:u32,
    absent_time:u32
}

impl Student{
    fn new(name:String,age:u8,score:u32) -> Self {
        Student{name:name,age:age,score:score, absent_time: 0 }
    }
    fn record(&mut self) {
        self.absent_time+=1
    }
}

pub mod Bank {
    pub struct Account {
        pub id:String,
        pub balance:u32
    }
    impl Account {
        pub fn new(id:String,balance:u32)->Self {
            Account{id:id,balance:balance}
        }
    }
}


fn main() {
    let mut s = Student::new("alice".to_string(), 20, 98);
    println!("name = {} age = {} score = {}",s.name,s.age,s.score);
    println!("absent before access = {}",s.absent_time);
    s.record();
    s.record();


    println!("absent before access = {}",s.absent_time);
    let account = Bank::Account::new("bob".to_string(), 100);
    println!("balance of {} is {}",account.id,account.balance)
}
```


### ÂÆ¢Êà∑Á´ØËØ∑Ê±Ç‰ª£Á†Å
```javascript
const web3 = require("@solana/web3.js");
const { randomInt } = require("crypto");
const fs = require("fs")
const PROGRAM = new web3.PublicKey("9HBtwrPSMi1gVFLt82oR8DVXtyfAFrpe1ePdvA9hsAoC")
const RPC = ""

/**
 * 
 * @param {Array<Number>} amounts 
 * @returns {Uint8Array}
 */
function constructBatchTransferIns(amounts) {
    const data = new Uint8Array(1+amounts.length*8);
    data[0]=amounts.length
    for (let i=0;i<amounts.length;i++) {
        new DataView(data.buffer).setBigUint64(1+i*8,BigInt(amounts[i]),true)
    }
    return data
}

async function batch_transfer(payerPath,num) {
    let receivers = []
    const connection = new web3.Connection(RPC)
    for (let i=0;i<num;i++) {
        const new_key = web3.Keypair.generate()
       fs.writeFileSync(`./keys/receivers_${i}.json`,JSON.stringify({
        pubkey:new_key.publicKey.toBase58(),
        secretKey:new_key.secretKey.toString()
       }))
        receivers.push(new_key)
    }
    const payer = web3.Keypair.fromSecretKey(new Uint8Array(JSON.parse(fs.readFileSync(payerPath).toString())))
    let amounts = []
    for (let i=0;i<num;i++) {
        amounts.push(10000000+randomInt(100000))
    }
    console.log("ËΩ¨Ë¥¶Êï∞È¢ù")
    console.log(amounts)
    const ins_data = constructBatchTransferIns(amounts)
    let account_infos=[];
    account_infos.push({
        isWritable:false,
        pubkey:web3.SystemProgram.programId,
        isSigner:false
    })
    for (let i=0;i<num;i++) {
        account_infos.push({
            isWritable:true,
            pubkey:receivers[i].publicKey,
            isSigner:false
        })
    }
    const tx = new web3.Transaction().add(new web3.TransactionInstruction({
        programId:PROGRAM,
        data:ins_data,
        keys:[
            {
                isWritable:true,
                isSigner:true,
                pubkey:payer.publicKey
            },
            ...account_infos
        ]
    }))
    const txid = await web3.sendAndConfirmTransaction(connection,tx,[payer])
    console.log(txid)

}

batch_transfer("payer.json",5)


```
